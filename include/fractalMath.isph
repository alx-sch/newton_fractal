// Defines the Complex structure and complex math operations for the ISPC kernel.

// Define the Complex structure (must be shared between C++ and ISPC for data transfer); in ISCP there is no built-in complex type (e.g. #include <complex>) :/
struct Complex
{
	double	real;
	double	imag;
};

// --- Function Prototypes ---
static Complex	complexSub(Complex a, Complex b);
static Complex	complexMul(Complex a, Complex b);
static Complex	complexDiv(Complex a, Complex b);
static Complex	complexPow(Complex z, uniform int n);

// --- Helper Functions ---
// Use 'static' -> private to compilation units

// Complex number subtraction: a - b
static Complex	complexSub(Complex a, Complex b)
{
	Complex	result;
	result.real = a.real - b.real;
	result.imag = a.imag - b.imag;

	return result;
}

// Complex number multiplication: (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
// Note: This is required for complex exponentiation (z^n).
static Complex	complexMul(Complex a, Complex b)
{
	Complex	result;
	result.real = a.real * b.real - a.imag * b.imag;
	result.imag = a.real * b.imag + a.imag * b.real;

	return result;
}

// Complex number division: (a + bi) / (c + di)
// See expansion of complex divison: https://www.cuemath.com/numbers/division-of-complex-numbers/
static Complex	complexDiv(Complex a, Complex b)
{
	Complex	result;
	double	mag_sq = b.real * b.real + b.imag * b.imag;

	// Avoid divide-by-zero
	if (mag_sq == 0.0)
	{
		result.real = 0.0;
		result.imag = 0.0;
		return result;
	}

	result.real = (a.real * b.real + a.imag * b.imag) / mag_sq;
	result.imag = (a.imag * b.real - a.real * b.imag) / mag_sq;

	return result;
}

// Calculates z^n (complex exponentiation).
// Since n is 'uniform', this calculation can be done in the same way for all threads.
static Complex	complexPow(Complex z, uniform int n)
{
	if (n == 0) // z^0 = 1
	{
		return {1.0, 0.0};
	}
	Complex	result = {1.0, 0.0}; // Start with 1

	Complex	base = z;
	for (uniform int i = 0; i < n; ++i)
	{
		result = complexMul(result, base);
	}

	return result;
}
