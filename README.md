# Newton Fractal Visualization with ISPC

This project generates a visualization of the **Newton Fractal** for the equation $z^n - 1 = 0$, utilizing the parallel processing power of the **ISPC** compiler.

#### Visualization of the Newton Fractal with Different Exponents ($n$):
| $n=5$ | $n=8$ | $n=13$ |
| :---: | :---: | :---: |
| <img src="https://raw.githubusercontent.com/alx-sch/NewtonFractal-ISPC/refs/heads/main/.assets/fractal_5n.png" width="95%" alt="Newton Fractal n=5"> | <img src="https://raw.githubusercontent.com/alx-sch/NewtonFractal-ISPC/refs/heads/main/.assets/fractal_8n.png" width="95%" alt="Newton Fractal n=8"> | <img src="https://raw.githubusercontent.com/alx-sch/NewtonFractal-ISPC/refs/heads/main/.assets/fractal_13n.png" width="95%" alt="Newton Fractal n=13"> |

--- 

## Getting Started

This project uses a standard `Makefile` for the build process and is designed to run in a Devcontainer for easy dependency management.

---

### Prerequisites and Setup

The project requires a C++ build chain and specific tools:

* **Make**: Build automation tool (the project uses a provided custom `Makefile` to coordinate C++/ISPC compilation).
* **ISPC Compiler**: Generates SIMD (Single instruction, multiple data) code from the parallel kernel source.
* **Imagemagick**: Required to convert the raw output files (`.ppm`) into a standard image format (`.png`).

#### Recommended Setup:   
The easiest way to ensure all dependencies are configured correctly is to use the provided Devcontainer setup.

#### Manual Installation Guide (Ubuntu): 
If you are not using the Devcontainer, follow these steps to install the required tools and the ISPC compiler:

1. **Install Standard Dependencies:**    
    ```bash
    # Install the core build tools, imagemagick, and file utilities
    sudo apt-get update
    sudo apt-get install -y make g++ valgrind imagemagick wget tar
    ```

2. **Install ISPC:**
   The ISPC compiler must be downloaded and manually placed into the system PATH.
   
    ```bash
    # 1. Download ISPC binary (v1.21.0)
    wget https://github.com/ispc/ispc/releases/download/v1.21.0/ispc-v1.21.0-linux.tar.gz

    # 2. Extract the archive
    tar -xzf ispc-v1.21.0-linux.tar.gz
    
    # 3. Move executable to the system PATH
    sudo mv ispc-v1.21.0-linux/bin/ispc /usr/local/bin/
    
    # 4. Cleanup downloaded files
    rm -rf ispc-v1.21.0-linux*
    ```

3. **Final Verification Check:**
   After installation, use the following commands to ensure all prerequisites are available and correctly linked in your environment:

   ```bash
    # Check if Make, g++ and Imagemagick are installed
    make --version | head -n 1
    g++ --version | head -n 1
    convert --version | head -n 1
    
    # Check if ISPC is installed and accessible
    ispc --version
    ```

---

### Building the Project

The project uses a provided custom `Makefile` to handle the two-stage compilation: ISPC kernel first, then the C++ host, followed by linking.

From the project root directory, run:

```bash
make
```

The resulting executable (`newton_fractal`) accepts the degree of the polynomial ($n$) as a command-line argument.

```bash
# Usage: ./newton_fractal <degree_n> <optional_width> <optional_height>

# Example 1: Generate a fractal for z^5 - 1 = 0 (5 roots)
./newton_fractal 5

# Example 2: Generate a fractal for z^8 - 1 = 0 with custom resolution
./newton_fractal 8 1024 768
```

#### Additional Make Targets

In addition to the default `make` command, the provided `Makefile` includes other useful convenience targets:

| Command | Purpose |
| :--- | :--- |
| `make clean` | **Removes intermediate build files** (object files and compiled ISPC kernels). Keeps the main executable. |
| `make fclean` | **Deep cleaning**. Removes all built artifacts, including object files, the final executable, and the output files (`.ppm` or `.png` files). Resets the repository to a clean state. |
| `make re` | **Full Rebuild**. Executes fclean followed by all. This ensures the project is completely cleaned and then rebuilt from scratch. |
| `make png` | **Runs the Imagemagick conversion** on the raw output file (converts `output.ppm` to `output.png`), in case your viewer has issues. |
| `make debug` | Builds the executable with a flag that enables **verbose runtime logging** (e.g. iteration details). Redirect to a logfile via shell redirection: `newton_fractal 5 2> log.txt`.

---

## The Newton Fractal

The Newton Fractal is a type of fractal derived from **Newton's Method** for finding the roots (solutions) of a complex equation $f(z) = 0$. 

The fractal is generated by plotting the complex plane

$$
z_0 = \text{Re}(z_0) + i \cdot \text{Im}(z_0)
$$ 

where:  
- **Hue (Color)**: Determined by which of the $n$ roots the iteration converges to.
- **Brightness/Saturation**: Determined by the number of iterations it takes to converge.

---

#### Finding the Roots:
The equation $z^n = 1$ is solved by understanding that the number $1$ can be expressed in the complex exponential form using the identity:  

$$
1 = e^{i 2\pi k}
$$

This follows from **Euler’s Formula**

$$
\mathbf{e^{i \theta} = \cos(\theta) + i\sin(\theta)}
$$

and the periodicity of sine and cosine, where $k$ is any integer representing full $2\pi$ rotations.

By setting the exponents equal and solving for $z$, we obtain the $n$ distinct roots of unity:

$$
z_k = \cos\left(\frac{2 \pi k}{n}\right) + i \sin\left(\frac{2 \pi k}{n}\right), \quad k = 0, 1, \dots, n-1
$$

---

#### The Iterative Process:

The iterative procedure of Newton’s method is defined as:

$$
z_{k+1} = z_k - \frac{f(z_k)}{f'(z_k)}
$$

The program runs this loop for a given starting complex number $z_0$, computing successive iterations $z_1, z_2, \dots$ until a convergence criterion is met — namely, when the distance between the current value $z_k$ ​and the nearest known root $r_i$ ​ becomes smaller than a tolerance $\epsilon$:

$$
|z_{k+1} - r_i| < \epsilon
$$

For $f(z) = z^n - 1$, the derivative is $f'(z) = n \cdot z^{n-1}$.

Substituting these into the Newton formula gives the specific iteration used in the implementation (and later parallelized in ISPC):

$$
z_{k+1} = z_k - \frac{z_k^n - 1}{n \cdot z_k^{n-1}}
$$

The **root index** ($i$) to which the iteration converges, together with the number of iterations required, determines the color of each pixel in the rendered image

---

## Intel ISPC

--- 

## References

<a name="footnote1">[1]</a> Rubine, D.; Quora (2017). [*How do I prove Euler Identity for any integer k?*](https://www.quora.com/How-do-I-prove-1-e-2-pi-ik-for-any-integer-k)     
